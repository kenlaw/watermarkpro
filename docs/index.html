<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iClass WatermarkPro</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (for JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- PDF Libraries -->
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    
    <!-- JSZip (For Batch Download) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .cursor-wait { cursor: wait; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 selection:bg-blue-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons Components (SVG) ---
        const Icon = ({ children, size = 20, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );

        const Icons = {
            Upload: (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></Icon>,
            X: (props) => <Icon {...props}><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></Icon>,
            FileText: (props) => <Icon {...props}><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/></Icon>,
            Image: (props) => <Icon {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></Icon>,
            Shield: (props) => <Icon {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></Icon>,
            Download: (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></Icon>,
            Settings: (props) => <Icon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></Icon>,
            RefreshCw: (props) => <Icon {...props}><polyline points="23 4 23 10 17 10"/><polyline points="1 20 1 14 7 14"/><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/></Icon>,
            AlertCircle: (props) => <Icon {...props}><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></Icon>,
            Sparkles: (props) => <Icon {...props}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/></Icon>,
            Zap: (props) => <Icon {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></Icon>,
            ChevronLeft: (props) => <Icon {...props}><polyline points="15 18 9 12 15 6" /></Icon>,
            ChevronRight: (props) => <Icon {...props}><polyline points="9 18 15 12 9 6" /></Icon>,
            Layers: (props) => <Icon {...props}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></Icon>,
            PenTool: (props) => <Icon {...props}><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></Icon>,
            Cpu: (props) => <Icon {...props}><rect x="4" y="4" width="16" height="16" rx="2" ry="2"/><rect x="9" y="9" width="6" height="6"/><line x1="9" y1="1" x2="9" y2="4"/><line x1="15" y1="1" x2="15" y2="4"/><line x1="9" y1="20" x2="9" y2="23"/><line x1="15" y1="20" x2="15" y2="23"/><line x1="20" y1="9" x2="23" y2="9"/><line x1="20" y1="14" x2="23" y2="14"/><line x1="1" y1="9" x2="4" y2="9"/><line x1="1" y1="14" x2="4" y2="14"/></Icon>
        };

        // --- PRESETS CONFIGURATION ---
        const PRESETS = [
            {
                name: "一般保密 (預設)",
                settings: {
                    text: "CONFIDENTIAL",
                    color: "#000000",
                    opacity: 0.20,
                    fontSize: 15,
                    rotation: -30,
                    density: 100,
                    enableOutlines: true,
                    enableNoise: true,
                    enableRandomization: true,
                    enableGradient: true,
                    outputQuality: 'normal'
                }
            },
            {
                name: "離線課本",
                settings: {
                    text: "All Rights Reserved © iClass 2026",
                    color: "#000000",
                    opacity: 0.10, // 10%
                    fontSize: 15,
                    rotation: -30,
                    density: 240,
                    enableOutlines: true,
                    enableNoise: true,
                    enableRandomization: true,
                    enableGradient: true,
                    outputQuality: 'high'
                }
            },
            {
                name: "僅轉外框 (無水印)",
                settings: {
                    text: "PROTECTED", // Placeholder
                    color: "#000000",
                    opacity: 0, // Invisible
                    fontSize: 15,
                    rotation: 0,
                    density: 100,
                    enableOutlines: true, // Must be TRUE
                    enableNoise: false,    // Clean background
                    enableRandomization: false,
                    enableGradient: false,
                    outputQuality: 'ultra' // Force Ultra Quality
                }
            }
        ];

        const App = () => {
            const [files, setFiles] = useState([]); 
            const [currentFileIdx, setCurrentFileIdx] = useState(0);
            const [previewUrl, setPreviewUrl] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [progressText, setProgressText] = useState("");
            const [isRenderingPdf, setIsRenderingPdf] = useState(false);

            // Settings State
            const [text, setText] = useState(PRESETS[0].settings.text);
            const [color, setColor] = useState(PRESETS[0].settings.color);
            const [opacity, setOpacity] = useState(PRESETS[0].settings.opacity);
            const [fontSize, setFontSize] = useState(PRESETS[0].settings.fontSize);
            const [rotation, setRotation] = useState(PRESETS[0].settings.rotation);
            const [density, setDensity] = useState(PRESETS[0].settings.density);

            // Strategies
            const [enableNoise, setEnableNoise] = useState(PRESETS[0].settings.enableNoise);
            const [enableRandomization, setEnableRandomization] = useState(PRESETS[0].settings.enableRandomization);
            const [enableGradient, setEnableGradient] = useState(PRESETS[0].settings.enableGradient);
            
            // Beta Features
            const [enableOutlines, setEnableOutlines] = useState(PRESETS[0].settings.enableOutlines); 
            
            // Quality Settings
            const [outputQuality, setOutputQuality] = useState('normal'); // 'low', 'normal', 'high', 'ultra'

            // AI Modal
            const [showAiModal, setShowAiModal] = useState(false);
            const [aiPrompt, setAiPrompt] = useState('');
            const [isAiLoading, setIsAiLoading] = useState(false);
            const [aiError, setAiError] = useState(null);

            const apiKey = ""; 

            // Apply Preset Function
            const applyPreset = (presetSettings) => {
                setText(presetSettings.text);
                setColor(presetSettings.color);
                setOpacity(presetSettings.opacity);
                setFontSize(presetSettings.fontSize);
                setRotation(presetSettings.rotation);
                setDensity(presetSettings.density);
                
                // Strategies Override
                if (presetSettings.enableOutlines !== undefined) setEnableOutlines(presetSettings.enableOutlines);
                if (presetSettings.enableNoise !== undefined) setEnableNoise(presetSettings.enableNoise);
                if (presetSettings.enableRandomization !== undefined) setEnableRandomization(presetSettings.enableRandomization);
                if (presetSettings.enableGradient !== undefined) setEnableGradient(presetSettings.enableGradient);
                if (presetSettings.outputQuality !== undefined) setOutputQuality(presetSettings.outputQuality);
            };

            // Init PDF Worker
            useEffect(() => {
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }
            }, []);

            // Handle Preview Update
            useEffect(() => {
                const updatePreview = async () => {
                    const currentFile = files[currentFileIdx];
                    if (!currentFile) {
                        setPreviewUrl(null);
                        return;
                    }

                    if (currentFile.type === 'application/pdf') {
                        setIsRenderingPdf(true);
                        try {
                            if (window.pdfjsLib) {
                                const fileArrayBuffer = await currentFile.arrayBuffer();
                                const loadingTask = window.pdfjsLib.getDocument(fileArrayBuffer);
                                const pdf = await loadingTask.promise;
                                const page = await pdf.getPage(1);
                                const viewport = page.getViewport({ scale: 1.5 });
                                const canvas = document.createElement('canvas');
                                const context = canvas.getContext('2d');
                                canvas.height = viewport.height;
                                canvas.width = viewport.width;
                                await page.render({ canvasContext: context, viewport: viewport }).promise;
                                setPreviewUrl(canvas.toDataURL());
                            }
                        } catch (error) {
                            console.error("PDF Preview Error:", error);
                        } finally {
                            setIsRenderingPdf(false);
                        }
                    } else if (currentFile.type.startsWith('image/')) {
                        setPreviewUrl(URL.createObjectURL(currentFile));
                    }
                };
                updatePreview();
            }, [files, currentFileIdx]);

            const handleFileChange = (e) => {
                const selectedFiles = Array.from(e.target.files);
                if (selectedFiles.length === 0) return;
                
                const validFiles = selectedFiles.filter(f => f.type === 'application/pdf' || f.type.startsWith('image/'));
                
                if (validFiles.length < selectedFiles.length) {
                    alert('部分文件格式不支援，已自動過濾。僅支援 PDF 與圖片。');
                }
                
                if (validFiles.length > 0) {
                    setFiles(validFiles);
                    setCurrentFileIdx(0);
                }
            };

            const clearFiles = () => {
                setFiles([]);
                setPreviewUrl(null);
                setCurrentFileIdx(0);
            };

            const nextFile = () => {
                setCurrentFileIdx((prev) => (prev + 1) % files.length);
            };

            const prevFile = () => {
                setCurrentFileIdx((prev) => (prev - 1 + files.length) % files.length);
            };

            // AI Logic
            const handleAiGenerate = async () => {
                if (!aiPrompt.trim()) return;
                setIsAiLoading(true);
                setAiError(null);

                try {
                    const systemPrompt = `
                        You are a document security expert. 
                        Based on the user's description of a document or its intended use, generate optimal watermark settings to prevent unauthorized usage or AI removal.
                        Output strictly in JSON format with this schema:
                        {
                        "text": "Suggested watermark text",
                        "color": "#hexcode",
                        "opacity": number (0.05 to 0.8),
                        "fontSize": number (12 to 72),
                        "rotation": number (-90 to 90),
                        "density": number (50 to 300),
                        "enableNoise": boolean,
                        "enableRandomization": boolean,
                        "enableGradient": boolean
                        }
                    `;

                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
                        {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: aiPrompt }] }],
                            systemInstruction: { parts: [{ text: systemPrompt }] },
                            generationConfig: { responseMimeType: "application/json" }
                        }),
                        }
                    );

                    if (!response.ok) throw new Error('AI Service Unavailable');

                    const data = await response.json();
                    const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    
                    if (resultText) {
                        const settings = JSON.parse(resultText);
                        setText(settings.text);
                        setColor(settings.color);
                        setOpacity(settings.opacity);
                        setFontSize(settings.fontSize);
                        setRotation(settings.rotation);
                        setDensity(settings.density);
                        setEnableNoise(settings.enableNoise);
                        setEnableRandomization(settings.enableRandomization);
                        setEnableGradient(settings.enableGradient);
                        setShowAiModal(false);
                        setAiPrompt('');
                    }
                } catch (error) {
                    console.error(error);
                    setAiError('無法生成設定，請稍後再試。');
                } finally {
                    setIsAiLoading(false);
                }
            };

            // Watermark Drawing Logic
            const drawWatermarkPattern = (ctx, width, height, shouldClear = true) => {
                if (shouldClear) {
                    ctx.clearRect(0, 0, width, height);
                }
                
                const REFERENCE_WIDTH = 600; 
                const scale = Math.max(0.1, width / REFERENCE_WIDTH);

                const sFontSize = fontSize * scale;
                const sDensity = density * scale;
                
                ctx.font = `bold ${sFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';

                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const step = sDensity + sFontSize; 
                const cols = Math.ceil(width / step) + 2;
                const rows = Math.ceil(height / step) + 2;

                for (let i = -2; i < cols; i++) {
                    for (let j = -2; j < rows; j++) {
                        const x = i * step;
                        const y = j * step;
                        ctx.save();
                        let posX = x;
                        let posY = y;

                        if (enableRandomization) {
                            posX += (Math.random() - 0.5) * (40 * scale);
                            posY += (Math.random() - 0.5) * (40 * scale);
                        }
                        ctx.translate(posX, posY);

                        let rot = rotation * (Math.PI / 180);
                        if (enableRandomization) {
                            rot += (Math.random() - 0.5) * 0.2; 
                        }
                        ctx.rotate(rot);

                        if (enableGradient) {
                            const gradient = ctx.createLinearGradient(-textWidth / 2, 0, textWidth / 2, 0);
                            gradient.addColorStop(0, color);
                            gradient.addColorStop(0.2, color);
                            gradient.addColorStop(0.5, '#bbbbbb');
                            gradient.addColorStop(0.8, color);
                            gradient.addColorStop(1, color);
                            ctx.fillStyle = gradient;
                        } else {
                            ctx.fillStyle = color;
                        }
                        
                        ctx.globalAlpha = opacity;
                        
                        // 1. Draw Text (Fill)
                        ctx.fillText(text, 0, 0);

                        // 2. Draw Outlines (Stroke) - Visual effect
                        if (enableOutlines) {
                            ctx.lineWidth = Math.max(0.5, sFontSize * 0.04); 
                            ctx.strokeStyle = color; 
                            ctx.strokeText(text, 0, 0);
                        }

                        if (enableNoise) {
                            ctx.fillStyle = `rgba(0,0,0,${opacity * 0.5})`;
                            for(let k=0; k<3; k++) {
                                const rx = (Math.random() - 0.5) * textWidth;
                                const ry = (Math.random() - 0.5) * sFontSize; 
                                ctx.fillRect(rx, ry, 2 * scale, 2 * scale); 
                            }
                        }
                        ctx.restore();
                    }
                }

                if (enableNoise) {
                    const imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i+3] > 0) {
                            if (Math.random() > 0.95) {
                                const noiseVal = Math.random() * 50;
                                data[i] = Math.max(0, data[i] - noiseVal);
                                data[i+1] = Math.max(0, data[i+1] - noiseVal);
                                data[i+2] = Math.max(0, data[i+2] - noiseVal);
                            }
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                }
            };

            const processImage = async (file) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise(resolve => img.onload = resolve);
                canvas.width = img.width;
                canvas.height = img.height;
                
                ctx.drawImage(img, 0, 0);
                
                const wmCanvas = document.createElement('canvas');
                wmCanvas.width = canvas.width;
                wmCanvas.height = canvas.height;
                const wmCtx = wmCanvas.getContext('2d');
                
                drawWatermarkPattern(wmCtx, canvas.width, canvas.height, true);
                ctx.drawImage(wmCanvas, 0, 0);
                
                let quality = 0.85;
                if (outputQuality === 'high') quality = 0.95;
                if (outputQuality === 'ultra') quality = 1.0;
                if (outputQuality === 'low') quality = 0.5;

                return new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
            };

            const processPdf = async (file) => {
                // If Outlines ON, RASTERIZE (Flatten) the PDF
                if (enableOutlines) {
                    if (!window.PDFLib || !window.pdfjsLib) throw new Error("Libraries not loaded");
                    
                    const newPdfDoc = await window.PDFLib.PDFDocument.create();
                    const fileArrayBuffer = await file.arrayBuffer();
                    const loadingTask = window.pdfjsLib.getDocument(fileArrayBuffer);
                    const pdf = await loadingTask.promise;
                    const numPages = pdf.numPages;

                    // Quality logic for PDF Rasterization - REVERTED TO v9 LOGIC
                    let scale = 2.0; 
                    let quality = 0.85; 
                    
                    if (outputQuality === 'high') {
                        scale = 3.0; 
                        quality = 0.95; // Restored high quality
                    } else if (outputQuality === 'ultra') {
                        scale = 5.0; // Restored Ultra 360DPI
                        quality = 1.0; // Restored full quality
                    } else if (outputQuality === 'low') {
                        scale = 1.0; 
                        quality = 0.6;
                    }

                    for (let i = 1; i <= numPages; i++) {
                        setProgressText(`正在光柵化處理頁面 ${i} / ${numPages} (Scale: ${scale}x)...`);
                        
                        const page = await pdf.getPage(i);
                        const viewport = page.getViewport({ scale });
                        
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        
                        await page.render({ canvasContext: ctx, viewport }).promise;

                        const wmCanvas = document.createElement('canvas');
                        wmCanvas.width = canvas.width;
                        wmCanvas.height = canvas.height;
                        const wmCtx = wmCanvas.getContext('2d');
                        
                        drawWatermarkPattern(wmCtx, canvas.width, canvas.height, true);
                        ctx.drawImage(wmCanvas, 0, 0);

                        const imgDataUrl = canvas.toDataURL('image/jpeg', quality); 
                        const jpgImage = await newPdfDoc.embedJpg(imgDataUrl);
                        const jpgDims = jpgImage.scale(1 / scale); 
                        
                        const newPage = newPdfDoc.addPage([jpgDims.width, jpgDims.height]);
                        newPage.drawImage(jpgImage, {
                            x: 0, y: 0, width: jpgDims.width, height: jpgDims.height,
                        });
                    }
                    const pdfBytes = await newPdfDoc.save();
                    return new Blob([pdfBytes], { type: 'application/pdf' });

                } else {
                    // Overlay Only Mode
                    if (!window.PDFLib) throw new Error("PDF Lib not loaded");
                    const arrayBuffer = await file.arrayBuffer();
                    const pdfDoc = await window.PDFLib.PDFDocument.load(arrayBuffer);
                    const pages = pdfDoc.getPages();
                    
                    let wWidth = 1000; 
                    let wHeight = 1414;
                    
                    if (outputQuality === 'high') { wWidth = 2000; wHeight = 2828; }
                    else if (outputQuality === 'ultra') { wWidth = 3000; wHeight = 4242; }
                    else if (outputQuality === 'low') { wWidth = 595; wHeight = 842; }

                    const watermarkCanvas = document.createElement('canvas');
                    watermarkCanvas.width = wWidth;
                    watermarkCanvas.height = wHeight;
                    const wCtx = watermarkCanvas.getContext('2d');
                    drawWatermarkPattern(wCtx, wWidth, wHeight, true);
                    const watermarkDataUrl = watermarkCanvas.toDataURL('image/png');
                    const watermarkImage = await pdfDoc.embedPng(watermarkDataUrl);

                    for (let i = 0; i < pages.length; i++) {
                        const page = pages[i];
                        const { width, height } = page.getSize();
                        page.drawImage(watermarkImage, {
                            x: 0, y: 0, width: width, height: height,
                        });
                    }
                    const pdfBytes = await pdfDoc.save();
                    return new Blob([pdfBytes], { type: 'application/pdf' });
                }
            };

            const handleDownload = async () => {
                if (files.length === 0) return;
                setIsProcessing(true);
                setProgressText(`準備處理 ${files.length} 個文件...`);

                try {
                    if (files.length === 1) {
                        const file = files[0];
                        let blob;
                        if (file.type.startsWith('image/')) {
                            blob = await processImage(file);
                        } else {
                            blob = await processPdf(file);
                        }
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = `watermarked_${file.name}`;
                        link.click();
                    } 
                    else {
                        if (!window.JSZip) {
                            alert("壓縮組件尚未加載，請重新整理頁面。");
                            return;
                        }
                        const zip = new window.JSZip();
                        
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            setProgressText(`正在處理 (${i + 1}/${files.length}): ${file.name}`);
                            
                            let blob;
                            try {
                                if (file.type.startsWith('image/')) {
                                    blob = await processImage(file);
                                } else {
                                    blob = await processPdf(file);
                                }
                                zip.file(`watermarked_${file.name}`, blob);
                            } catch (e) {
                                console.error(`Error processing ${file.name}`, e);
                            }
                        }

                        setProgressText("正在打包壓縮...");
                        const content = await zip.generateAsync({type: "blob"});
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(content);
                        link.download = "watermarked_files.zip";
                        link.click();
                    }

                } catch (err) {
                    console.error(err);
                    alert('處理失敗，請重試。若開啟了轉外框功能且文件頁數過多，建議分批處理。');
                } finally {
                    setIsProcessing(false);
                    setProgressText("");
                }
            };

            const PreviewLayer = () => {
                const canvasRef = useRef(null);
                useEffect(() => {
                    const canvas = canvasRef.current;
                    if(!canvas) return;
                    const parent = canvas.parentElement;
                    canvas.width = parent.offsetWidth;
                    canvas.height = parent.offsetHeight;
                    const ctx = canvas.getContext('2d');
                    drawWatermarkPattern(ctx, canvas.width, canvas.height, true);
                }, [text, color, opacity, fontSize, rotation, density, enableNoise, enableGradient, enableRandomization, enableOutlines, previewUrl]);
                return <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full pointer-events-none z-10" />;
            };

            return (
                <div className="min-h-screen bg-slate-50">
                    <header className="bg-white border-b border-slate-200 py-6 text-center relative">
                        <h1 className="text-3xl font-extrabold text-slate-900 tracking-tight">
                            iClass Watermark<span className="text-blue-600">Pro</span>
                        </h1>
                        <p className="mt-2 text-slate-500 text-sm">為您的圖片或 PDF 文件添加專業浮水印，支援防 AI 移除策略，安全、快速、本地處理。</p>
                        <div className="absolute top-2 right-2 text-[10px] text-slate-400 font-mono opacity-50 hover:opacity-100 transition-opacity cursor-default" title="System Version">
                            Version 1.26020309
                        </div>
                    </header>

                    <main className="max-w-5xl mx-auto p-6 space-y-6">
                        {/* Preview Box */}
                        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden relative min-h-[500px] flex flex-col">
                            <div className="p-4 border-b border-slate-100 flex justify-between items-center bg-slate-50/50">
                                <div className="flex items-center gap-2 text-slate-500 font-medium">
                                    <Icons.FileText size={18} />
                                    <span>
                                        {files.length > 0 
                                            ? `預覽: ${files[currentFileIdx].name} (${currentFileIdx + 1}/${files.length})` 
                                            : '預覽模式'}
                                    </span>
                                </div>
                                {files.length > 0 && (
                                    <button onClick={clearFiles} className="flex items-center gap-1 text-red-500 hover:text-red-600 text-sm font-medium transition-colors">
                                        <Icons.X size={16} /> 清除所有 ({files.length})
                                    </button>
                                )}
                            </div>
                            <div className="flex-1 relative flex items-center justify-center bg-slate-100/50 p-8 overflow-hidden group/preview">
                                {files.length === 0 ? (
                                    <div className="text-center py-12 px-6 border-2 border-dashed border-slate-300 rounded-xl hover:border-blue-400 hover:bg-blue-50 transition-all cursor-pointer group w-full max-w-lg bg-white relative">
                                        <input type="file" multiple onChange={handleFileChange} className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" accept="image/*,.pdf" />
                                        <div className="w-16 h-16 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center mb-4 mx-auto group-hover:scale-110 transition-transform">
                                            <Icons.Upload size={32} />
                                        </div>
                                        <h3 className="text-lg font-semibold text-slate-700">點擊或拖放文件至此</h3>
                                        <p className="text-slate-400 text-sm mt-1">支援批量上載 PDF 與圖片 (最大 500 頁)</p>
                                        <div className="mt-4 flex items-center justify-center gap-2 text-xs text-blue-500 font-medium bg-blue-50 py-1 px-3 rounded-full w-fit mx-auto">
                                            <Icons.Layers size={14} /> 支援同時選取多個文件
                                        </div>
                                    </div>
                                ) : (
                                    <div className="relative w-full h-full flex items-center justify-center">
                                        
                                        {/* Navigation Arrows */}
                                        {files.length > 1 && (
                                            <>
                                                <button onClick={prevFile} className="absolute left-4 z-20 p-2 bg-white/80 hover:bg-white rounded-full shadow-lg text-slate-600 hover:text-blue-600 transition-all backdrop-blur-sm">
                                                    <Icons.ChevronLeft size={24} />
                                                </button>
                                                <button onClick={nextFile} className="absolute right-4 z-20 p-2 bg-white/80 hover:bg-white rounded-full shadow-lg text-slate-600 hover:text-blue-600 transition-all backdrop-blur-sm">
                                                    <Icons.ChevronRight size={24} />
                                                </button>
                                            </>
                                        )}

                                        {previewUrl ? (
                                            <div className="relative shadow-lg max-h-[600px] inline-block transition-all duration-300">
                                                <img src={previewUrl} alt="Preview" className="max-h-[600px] max-w-full rounded border border-slate-200 bg-white" />
                                                <PreviewLayer />
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center text-slate-400 animate-pulse">
                                                {isRenderingPdf ? (
                                                    <>
                                                        <Icons.RefreshCw className="animate-spin mb-2" size={32} />
                                                        <p>正在渲染 PDF 預覽...</p>
                                                    </>
                                                ) : (
                                                    <>
                                                        <Icons.FileText size={48} className="mb-2" />
                                                        <p>無法預覽此文件</p>
                                                    </>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Controls */}
                        <div className="bg-white rounded-2xl shadow-sm border border-slate-200 p-6">
                            <div className="flex items-center justify-between gap-2 mb-6 pb-4 border-b border-slate-100">
                                <div className="flex items-center gap-2">
                                    <Icons.Settings className="text-slate-400" />
                                    <h2 className="text-lg font-bold text-slate-800">浮水印設置</h2>
                                </div>
                                <button 
                                    onClick={() => setShowAiModal(true)}
                                    className="flex items-center gap-1.5 px-3 py-1.5 bg-gradient-to-r from-violet-600 to-indigo-600 text-white text-sm font-medium rounded-full shadow-md hover:shadow-lg hover:from-violet-500 hover:to-indigo-500 transition-all"
                                >
                                    <Icons.Sparkles size={14} />
                                    AI 推薦設定
                                </button>
                            </div>

                            {/* Presets Row */}
                            <div className="mb-8 p-4 bg-slate-50 rounded-xl border border-slate-200">
                                <h3 className="text-sm font-semibold text-slate-700 mb-3 flex items-center gap-2">
                                    <Icons.Zap size={16} className="text-amber-500"/>
                                    快速設定 (Quick Presets)
                                </h3>
                                <div className="flex flex-wrap gap-2">
                                    {PRESETS.map((preset, idx) => (
                                        <button
                                            key={idx}
                                            onClick={() => applyPreset(preset.settings)}
                                            className="px-4 py-2 bg-white border border-slate-200 hover:border-blue-400 hover:bg-blue-50 text-slate-700 text-sm rounded-lg transition-all shadow-sm active:scale-95 flex flex-col items-start"
                                        >
                                            <span className="font-medium">{preset.name}</span>
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                                {/* Settings Column */}
                                <div className="lg:col-span-7 space-y-6">
                                    <div>
                                        <label className="block text-sm font-medium text-slate-700 mb-2">浮水印文字</label>
                                        <div className="relative">
                                            <span className="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400"><Icons.FileText size={18} /></span>
                                            <input 
                                                type="text" 
                                                value={text} 
                                                onChange={(e) => setText(e.target.value)}
                                                className="w-full pl-10 pr-4 py-3 bg-slate-50 border border-slate-200 rounded-xl focus:ring-2 focus:ring-blue-500 outline-none transition-all"
                                                placeholder="輸入文字..." 
                                            />
                                        </div>
                                        <div className="flex flex-wrap gap-2 mt-2">
                                            <button 
                                                onClick={() => setText("CONFIDENTIAL")} 
                                                className="text-xs bg-slate-100 hover:bg-slate-200 text-slate-600 px-3 py-1.5 rounded-lg border border-slate-200 transition-colors"
                                            >
                                                CONFIDENTIAL
                                            </button>
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-slate-700">顏色</label>
                                                <span className="text-xs text-slate-400 font-mono">{color}</span>
                                            </div>
                                            <div className="flex items-center gap-3 bg-slate-50 p-2 rounded-xl border border-slate-200">
                                                <input type="color" value={color} onChange={(e) => setColor(e.target.value)} className="w-10 h-10 rounded-lg cursor-pointer border-none p-0 bg-transparent" />
                                                <span className="text-sm text-slate-500">選擇顏色</span>
                                            </div>
                                        </div>
                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-slate-700">透明度: {Math.round(opacity * 100)}%</label>
                                            </div>
                                            <input type="range" min="0" max="1" step="0.05" value={opacity} onChange={(e) => setOpacity(parseFloat(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                                        </div>
                                    </div>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-slate-700">字體大小: {fontSize}px</label>
                                            </div>
                                            <input type="range" min="12" max="72" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                                        </div>
                                        <div>
                                            <div className="flex justify-between mb-2">
                                                <label className="text-sm font-medium text-slate-700">旋轉角度: {rotation}°</label>
                                            </div>
                                            <input type="range" min="-90" max="90" value={rotation} onChange={(e) => setRotation(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                                        </div>
                                    </div>
                                    <div>
                                        <div className="flex justify-between mb-2">
                                            <label className="text-sm font-medium text-slate-700">密度 (重複間距): {density}px</label>
                                        </div>
                                        <input type="range" min="50" max="300" step="10" value={density} onChange={(e) => setDensity(parseInt(e.target.value))} className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600" />
                                        <div className="flex justify-between text-xs text-slate-400 mt-1"><span>密集 (50px)</span><span>稀疏 (300px)</span></div>
                                    </div>

                                    {/* New: Output Quality Settings */}
                                    <div className="bg-slate-100/50 p-4 rounded-xl border border-slate-200">
                                        <div className="flex items-center gap-2 mb-3 text-slate-700 font-bold text-sm">
                                            <Icons.Cpu size={16} />
                                            <h3>輸出畫質 (Output Quality)</h3>
                                        </div>
                                        <div className="flex gap-2">
                                            {[
                                                { id: 'ultra', label: '超高清', desc: '最佳 (360DPI)' },
                                                { id: 'high', label: '高畫質', desc: '印刷用 (216DPI)' },
                                                { id: 'normal', label: '普通', desc: '螢幕用 (150DPI)' },
                                                { id: 'low', label: '快速', desc: '預覽用 (72DPI)' },
                                            ].map((q) => (
                                                <button
                                                    key={q.id}
                                                    onClick={() => setOutputQuality(q.id)}
                                                    className={`flex-1 py-2 px-1 rounded-lg border transition-all text-sm flex flex-col items-center gap-0.5 ${outputQuality === q.id ? 'bg-white border-blue-500 shadow-md text-blue-600 ring-1 ring-blue-500' : 'bg-slate-50 border-transparent hover:bg-white hover:border-slate-300 text-slate-500'}`}
                                                >
                                                    <span className="font-bold text-xs lg:text-sm">{q.label}</span>
                                                    <span className="text-[10px] opacity-75">{q.desc}</span>
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                </div>

                                {/* Strategies Column */}
                                <div className="lg:col-span-5 flex flex-col gap-6">
                                    <div className="bg-indigo-50/50 rounded-xl p-6 border border-indigo-100">
                                        <div className="flex items-center gap-2 mb-4 text-indigo-900 font-bold">
                                            <Icons.Shield className="w-5 h-5 text-indigo-600" />
                                            <h3>防 AI 移除增強策略</h3>
                                        </div>
                                        <p className="text-xs text-indigo-700/80 mb-6">啟用這些選項可以增加浮水印被 AI 工具自動移除的難度。</p>
                                        <div className="space-y-4">
                                            {[
                                                { label: '雜訊干擾 (Noise)', desc: '添加隨機像素點，破壞邊緣', val: enableNoise, set: setEnableNoise },
                                                { label: '隨機化分佈 (Randomization)', desc: '微調每個文字的角度與位置', val: enableRandomization, set: setEnableRandomization },
                                                { label: '漸層色填充 (Gradient)', desc: '使用非純色填充，干擾取樣', val: enableGradient, set: setEnableGradient }
                                            ].map((item, idx) => (
                                                <label key={idx} className="flex items-center justify-between p-3 bg-white rounded-lg border border-indigo-100 shadow-sm cursor-pointer hover:border-indigo-300 transition-colors">
                                                    <div className="flex flex-col">
                                                        <span className="font-medium text-slate-800 text-sm">{item.label}</span>
                                                        <span className="text-xs text-slate-400">{item.desc}</span>
                                                    </div>
                                                    <div className={`w-11 h-6 flex items-center rounded-full p-1 transition-colors duration-300 ${item.val ? 'bg-indigo-600' : 'bg-slate-300'}`} onClick={(e) => { e.preventDefault(); item.set(!item.val); }}>
                                                        <div className={`bg-white w-4 h-4 rounded-full shadow-md transform duration-300 ${item.val ? 'translate-x-5' : ''}`} />
                                                    </div>
                                                </label>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Beta Features Section - NEW */}
                                    <div className="bg-amber-50/50 rounded-xl p-6 border border-amber-100">
                                        <div className="flex items-center gap-2 mb-4 text-amber-900 font-bold">
                                            <Icons.PenTool size={18} className="text-amber-600" />
                                            <h3>內部測試功能 (Beta)</h3>
                                        </div>
                                        
                                        <label className="flex items-center justify-between p-3 bg-white rounded-lg border border-amber-100 shadow-sm cursor-pointer hover:border-amber-300 transition-colors">
                                            <div className="flex flex-col">
                                                <span className="font-medium text-slate-800 text-sm">文字轉外框 / 內容光柵化 (Rasterize Text)</span>
                                                <span className="text-xs text-slate-400">將 PDF 頁面轉為圖像，確保文字無法被選取或複製 (處理速度較慢)</span>
                                            </div>
                                            <div className={`w-11 h-6 flex items-center rounded-full p-1 transition-colors duration-300 ${enableOutlines ? 'bg-amber-500' : 'bg-slate-300'}`} onClick={(e) => { e.preventDefault(); setEnableOutlines(!enableOutlines); }}>
                                                <div className={`bg-white w-4 h-4 rounded-full shadow-md transform duration-300 ${enableOutlines ? 'translate-x-5' : ''}`} />
                                            </div>
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <div className="mt-8 pt-6 border-t border-slate-100 flex justify-end">
                                <button 
                                    onClick={handleDownload}
                                    disabled={files.length === 0 || isProcessing}
                                    className={`flex items-center gap-2 px-8 py-3 rounded-xl font-bold text-white shadow-lg shadow-blue-200 transition-all ${files.length === 0 || isProcessing ? 'bg-slate-400 cursor-not-allowed shadow-none' : 'bg-blue-600 hover:bg-blue-700 active:scale-95'}`}
                                >
                                    {isProcessing ? (
                                        <>
                                            <Icons.RefreshCw className="animate-spin" size={20} /> 
                                            {progressText || '處理中...'}
                                        </>
                                    ) : (
                                        <>
                                            <Icons.Download size={20} /> 
                                            {files.length > 1 ? `批量下載 ${files.length} 個文件 (.zip)` : '下載處理後的文件'}
                                        </>
                                    )}
                                </button>
                            </div>
                        </div>

                        {/* AI Modal */}
                        {showAiModal && (
                            <div className="fixed inset-0 bg-slate-900/50 flex items-center justify-center z-50 p-4 backdrop-blur-sm">
                                <div className="bg-white rounded-2xl shadow-xl w-full max-w-lg overflow-hidden animate-in fade-in zoom-in duration-200">
                                    <div className="bg-gradient-to-r from-violet-600 to-indigo-600 p-6 text-white">
                                        <div className="flex justify-between items-start">
                                            <div>
                                                <h3 className="text-xl font-bold flex items-center gap-2"><Icons.Sparkles size={20} /> AI 智慧設定顧問</h3>
                                                <p className="text-indigo-100 text-sm mt-1">告訴我您的文件用途，我來幫您設定最佳防護。</p>
                                            </div>
                                            <button onClick={() => setShowAiModal(false)} className="text-indigo-200 hover:text-white transition-colors"><Icons.X size={20} /></button>
                                        </div>
                                    </div>
                                    <div className="p-6">
                                        <div className="mb-4">
                                            <label className="block text-sm font-medium text-slate-700 mb-2">文件用途描述</label>
                                            <textarea 
                                                value={aiPrompt}
                                                onChange={(e) => setAiPrompt(e.target.value)}
                                                placeholder="例如：公司內部機密會議記錄、個人攝影作品集、租屋身分證影本..."
                                                className="w-full h-32 p-3 bg-slate-50 border border-slate-200 rounded-xl focus:ring-2 focus:ring-indigo-500 outline-none resize-none text-slate-800"
                                            />
                                        </div>
                                        {aiError && (
                                            <div className="mb-4 p-3 bg-red-50 text-red-600 rounded-lg text-sm flex items-center gap-2">
                                                <Icons.AlertCircle size={16} /> {aiError}
                                            </div>
                                        )}
                                        <div className="flex justify-end gap-3">
                                            <button onClick={() => setShowAiModal(false)} className="px-4 py-2 text-slate-500 hover:bg-slate-100 rounded-lg font-medium">取消</button>
                                            <button 
                                                onClick={handleAiGenerate}
                                                disabled={isAiLoading || !aiPrompt.trim()}
                                                className={`flex items-center gap-2 px-6 py-2 bg-indigo-600 text-white rounded-lg font-medium hover:bg-indigo-700 transition-colors shadow-md ${isAiLoading ? 'opacity-70 cursor-wait' : ''}`}
                                            >
                                                {isAiLoading ? <><Icons.RefreshCw size={16} className="animate-spin" /> 分析中...</> : <><Icons.Sparkles size={16} /> 生成最佳設定</>}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
